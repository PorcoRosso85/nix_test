# No surprises on any system
https://stackoverflow.blog/2023/10/02/no-surprises-on-any-system-q-and-a-with-loris-cro-of-zig/


RD:ジグのどんなところに注目しましたか?

LC: 2 つの主な点があると思います。1 つは技術的な点、もう 1 つは、まあ、それほどでもない点です。Zig に関して私が本当に注目した技術的な点は、comptimeです。Zig はメタプログラミングを行いますが、マクロを使ったメタプログラミングは行いません。代わりに、 comptime と呼ばれる別のシステムを使用します。

マクロは非常に強力ですが、基本的にはソース コードの構文を多かれ少なかれ操作するプログラムであるため、非常に脆弱でもあります。前述したように、これは非常に強力ですが、テキストをいじっているため非常に脆弱でもあります。意味の一部が失われ、単なるトークンになります。

私はメタプログラミングが好きですが、マクロはひどいと思います。comptime では、言語自体を使用して、言語の一部をよりセマンティックな方法で操作します。言語をデータ構造として扱います。Lisp の場合と似ていますが、Lisp 言語ではありません。いくつかの重要な違いがあります。

2 つ目は、作成者の Andrew が GitHub 上で人々とやり取りする様子を観察することです。Andrew は貢献者とやり取りしたり、新規ユーザーを指導したりする際に非常に効果的なアプローチをとっており、すべてのやり取りが双方にとって生産的なものになるように配慮していることにすぐに気付きました。この強みは、技術的な理由だけでなく、Zig が今日のような地位にある理由の一部であると思います。

RD:今では非常に多くの言語が存在し、成熟したものも数多くあります。アンケート調査ではいつも Rust ファンが多く回答します。メタプログラミング以外に、Zig が生まれたのはなぜだと思いますか?

LC:なぜですか? 実は、Zig の誕生については、公式に認められたストーリーがあるんです。Andrew は、デジタル オーディオ ワークステーション、つまりオーディオをリアルタイムで操作するソフトウェア ツールを作りたかったんです。これはリアルタイムである必要があるため、非常に要求の厳しい分野です。高速である必要があります。彼はいくつかの異なる言語を試しました。Go、C、JavaScript を試しました。彼は常に、それらには欠点があると感じていました。

最終的に彼が求めていたのは、C にもっと似ているが、主な明らかなフット ガンが解決され、改善されたものだった。それが彼が Zig を始めたときだった。

RD:指針となる原則の 1 つはシンプルさ、特に制御フローとメモリ割り当てに関して、驚きが起こらないようにすることだと気づきました。

LC:まさにその通りです。デジタル オーディオ ワークステーションの例に戻ると、こうした点に注意しないと、良いものを作ることが不可能になってしまうからです。

RD:そうすると、速くてほぼ決定論的になるようです。つまり、何が起こるかが分かっているということです。そこには動的な驚きはありません。

LC:私の意見では、それが C の最大の強みかもしれません。振り返ってみると、C には非常に多くの問題や悪い点がありますが、美しさもあります。C の美しさの主な要素は、コードにジャンプして、マクロに夢中になっていなければ、何が起こっているのか簡単にわかるという事実だと思います。

これは、演算子をオーバーロードできず、メモリ割り当てを隠すことができないためです。実際、Zig では、これは C でさえ行わないほど極端になっています。たとえば、C では、関数はZig でmalloc が使用可能であると想定しているため、必ずしもアロケータを指定しなくても割り当てを行う関数があります。

これは標準ではありません。Zigでは、すべてのデータ構造が明示的にアロケータを取り込みます。プログラムのどの部分がメモリを割り当て、どの部分が割り当てないかを理解する方がさらに明確になります。

RD:つまり、メモリを具体的に割り当てて制限したい場合、つまりメモリの正確なアドレスを取得したい場合、それが可能ということですね?

Loris:そうです。しかし、さらに重要なのは、アロケータに関しては常に依存関係の反転または注入の形式をとること、つまり呼び出し元がアロケータを指定することで、使いやすさも大幅に向上するということです。

たとえば、WebAssembly では、メモリの動作方法に厳しい制限があります。WASM をターゲットにしている場合、割り当てるものはすべて WASM アロケータを受け入れることができるため、標準ライブラリのすべてのデータ構造は例外なく WebAssembly で使用できます。

同様に、埋め込みデータ構造の場合、非常に制約の多い環境にあり、メモリ割り当てに関して動的な動作をするデータ構造を使用したいのですが、実際のヒープはありません。スタックにバッファを割り当ててスタック アロケータを作成すると、基本的にスタックのメモリ チャンクを「ヒープ」として使用します。次に、それをハッシュ マップなどの他のデータ構造に渡します。

もちろん、制限はあります。実際の 64 ギガバイトのヒープがある場合と比べて、データ構造を完全な柔軟性で使用できません。しかし、これは機能します。また、コードの再利用性がはるかに高まります。

RD:デジタル オーディオ ワークステーションから Zig が誕生したという話をしましたが、ベアメタルでの Zig の利点や標準ライブラリをオプションにすることなどについて多くの議論があります。これを作成して、基本的なベアメタル言語にするために開発する意図はありましたか?

LC:そうです。Zig のキャッチフレーズは、私が考案に協力したのですが、「Zig は、堅牢で最適かつ再利用可能なソフトウェアを維持するための汎用プログラミング言語およびツール チェーンです」です。再利用性についてはお話ししましたよね? それが 1 つの重要なポイントです。堅牢性と最適性を求めるなら、言語は低レベルでなければなりません。最適性は自明だからです。

マシンを正確に制御する必要があります。そうしないと、最適な処理を実行できません。しかし、堅牢性もそこから生まれます。たとえば、JavaScript で何かを記述してメモリが不足すると、プログラムはクラッシュします。JavaScript を記述する人には、クラッシュしないという選択肢はありません。なぜなら、言語にはメモリ割り当てが成功することを想定した機能が組み込まれているからです。それが失敗すると、エンジン レベルでクラッシュするしかありません。しかし、Zig ではそのようなことは起こりません。メモリ不足でクラッシュすることのないプログラムを作成できます。

一例として、分散金融データベースであるTigerBeetleが挙げられますが、このデータベースでは堅牢性を重視しています。堅牢性とは、もちろん正確性ですが、データベースでもあります。クラッシュしたら大変ですよね。メモリ不足でもクラッシュします。基本的に、起動時に大量のメモリを前もって割り当てます。その後は、メモリを一切割り当てません。

これは本当に素晴らしいことです。メモリ不足によってプロセスが強制終了されることがなくなるからです。これはソフトウェアにさらなる堅牢性を与える非常に優れた特性です。

説明で使用しているキーワードがもう 1 つあります。これは非常に重要なものですが、あまり意識されていません。Zig は汎用プログラミング言語として定義されています。Zig の背後にある考え方は、大型コンピューターだけでなく、組み込みデバイス、ハードウェア、マイクロコントローラーを搭載したあらゆるものにも使用できるというものです。この説明に当てはまるものはすべて、Zig でプログラムできるはずだというのが考え方です。

RD:標準ライブラリがオプションだったときに、私もそう思いました。このプログラミング言語は、できるだけ小さく、できるだけ高速にしたいですよね。デバイス上で Zig が使用されている例はありますか?

LC:スタートアップを紹介することはできませんが、MicroZigというプロジェクトを紹介することはできます。これは、基本的にハードウェア抽象化レイヤーを書いているこのコミュニティのメンバーによって運営されているプロジェクトです。アイデアとしては、たとえば Raspberry Pi を持っていて、ビルド スクリプトでボードの種類を指定するだけで、comptime を通じてボードに一致する型定義が自動的に取得されます。ピンの数は同じで、すべてのピンが物理デバイスにマップされるなどです。これにより、メタデバイスの開発がはるかに容易になります。

私たちが本当に気にかけているもう 1 つのことは、クロス コンパイルです。Linux を使用している場合は、クラス用または Windows 用の実行ファイルをビルドできます。その逆も可能です。これは便利ですが、組み込みデバイスを扱う場合には重要になります。組み込みデバイスでは、コンピューター上でコンパイルしてから、バイナリ ブロブをデバイス自体にアップロードするからです。つまり、ある意味では常にクロス コンパイルです。

私たちはすでに 2 回の Zig カンファレンスを対面で開催しており、その両方で MicroZig ワークショップを開催しました。これらのワークショップでは、Windows ラップトップ、Mac OS、Linux マシン、Arm、x86 などの組み合わせで人々が集まりました。毎回、デバイスを接続するだけで、最初の試行で常に動作しました。Zig で何かをコンパイルするたびに、システム依存関係に依存する可能性がありますが、Zig を使用すると、それを回避するのが非常に簡単になり、ソフトウェアを本当にポータブルにすることができます。

RD:それはとてもクールですね。言語とツール チェーンだというのは興味深いですね。最初にメールをやり取りしたときは、コンパイラについてだけ話していましたが、コンパイラが言語の大きな部分を占めていることは知っています。コンパイラがなぜそれほど重要なのか、お話しいただけますか。

ロリス: 2 つの側面があります。1 つは、より一般的なもので、先ほど説明したクロス コンパイルです。ただし、より具体的には、Zig コードのクロス コンパイルだけをサポートしているわけではありません。C および C++ コードのクロス コンパイルもサポートしています。つまり、Zig は Zig コンパイラであるだけでなく、C コンパイラでもあります。すべてがゼロから作られているわけではありません。

基本的に私たちがやっていることは、Clang をバンドルすることです[編集者注: Clang のオリジナル作成者である Chris Lattner とのポッドキャストをご覧ください]。Zig は最適化のためにLLVMに依存しており、私たちはすでに LLVM に依存しているため、基本的に Clang を Zig にバンドルすることも簡単です。zig cc zigを実行すると、ccサブコマンドは Clang のフラグ互換の代替になります。ただし、すぐに Clang にリダイレクトされるわけではありません。

Zig はフラグの前処理を行い、独自のロジックを追加します。たとえば、クロスコンパイルを行う場合、自動的に設定されます。Windows から Linux にクロスコンパイルするとします。Windows 上でも、Linux libcのインポート パスが自動的に設定されます。Clangを含むコンパイラは通常、システムのものだけを使用すると想定しますが、これはクロスコンパイルには機能しません。

キャッシュを行います。Clang に到達する前に、他にもいくつかの処理を行います。C と C++ に関しては、コンパイラ自体と libc の依存関係の問題だけではなく、ターゲットを理解するために必要なツールもいくつかあります。

たとえば、リンカーは Windows のターゲット固有のリンクを実行しますが、これは MacOS や Linux の実行可能ファイルのリンクとは異なります。arなどのツールは、プログラマーとして実際にはほとんどの場合あまり気にすることはないのですが、クロス補完が実際に機能するためには必要です。

ツール チェーン部分は本物です。ダウンロードすると 40 MB の tarball になり、 glibcのさまざまなバージョンが含まれます。これは通常、コンパイラが行わないことです。glibc をターゲットにできるだけでなく、 glibcの特定のバージョンをターゲットにすることもできます。

たとえば、Uber は システムlibcに依存しており、特定のバージョンのglibcを必要とするマシンがいくつかあるため、 Zigを使用して Go プログラムをクロスコンパイルしています。

基本的にはクロスコンパイルですが、言語自体に限りません。たとえば、Rust は Rust をクロスコンパイルできますが、C をクロスコンパイルすることはできません。C ライブラリに依存している場合、クロスコンパイルに関するエクスペリエンスは大きく異なります。

Go でも同じです。Cライブラリに依存するために使用するコマンドであるcgoは、クロスコンパイルのエクスペリエンスが低下するため Go ではないという有名な ブログ投稿があります。

しかし、Rust と Go はどちらも Zig を使用して C と C++ のクロス コンパイルを提供できるため、基本的にこの作業を実行し、C 依存関係のクロス コンパイルを提供するCargo Zig Buildなどのプロジェクトがあります。

RD:そうすることで、自動的に利用できるエコシステムが得られるということのようですね。すべての C ライブラリが手に入ります。

もう一つお聞きしたいことがあります。あなたはコミュニティ担当副社長ですが、Andrew は当初からコミュニティの構築に力を入れていました。現在の Zig コミュニティはどのような様子ですか?

ロリス: Zig コミュニティとプロジェクトについて私が言える最も興味深い 2 つの点は、まず第一に、このプロジェクトはBDFL によって運営されていることです。他の言語と比べると、私たちにはすべての設計上の決定について最終決定権を持つBDFLであるAndrew がいます。彼がすべてを行うわけではありません。彼は高い塔の頂上から独りですべての決定を下すわけではありません。他のコア コントリビューターや協力者も、私たちの活動に意見を述べています。

しかし、例えば、言語機能の提案がある GitHub の問題がある場合、賛成の数が最終的な結果に影響を与えると考える人が時々いますが、それはまったく影響しません。これが、プロジェクトの根幹をなす仕組みです。

その代わり、その周囲のコミュニティは非常に自由で、公式コミュニティはなく、コミュニティは分散化されています。つまり、GitHub 以外に公式のコミュニティの場がないということです。たとえば、大きな Discord サーバーはありますが、公式ではありません。Andrew や私が運営しているわけではありません。私はそこでモデレーターを務めていますが、オーナーではありません。各コミュニティが独自の行動規範を設定するという考えです。コミュニティが自分たちの場所をどのように運営するかを決定します。

これは、他の言語で行われる傾向とは非常に異なっていると思います。他の言語では、公式の場所がある傾向がありますが、私たちにはそれがありません。

RD:特に、慈悲深い独裁者がいる国では、コミュニティを中央集権化しようとする傾向があります。

LC:ええ、私たちの場合はそうではありません。

RD:多くの言語がサポートのために財団を設立しています。Zig Foundation の運営方法についてお話しいただけますか?

LC: Zig Foundation の興味深い点は、501(c)(6) ではないことです。他の多くの非営利団体は基本的に業界団体ですが、私たちは 501(c)(3) なので、完全に免税で開発者に報酬を支払っています。

私たちが受け取るお金のほとんどは寄付金ですが、サポート契約など他のものからの収入も時々ありますが、その 90 パーセント以上が開発者に渡され、残りはインフラストラクチャ、CI、管理コストに使用されます。

対面式のカンファレンスは 2 回開催したので、まだ規模は小さいのですが、「Software You Can Love 」というカンファレンスを 2 回開催しました。Zig だけのカンファレンスではありませんが、通常は 2 日間を Zig に充てています。1 日はワークショップ、もう 1 日は Zig に関する講演です。そして、1 日はソフトウェア全般に関する講演です。これは、ZigConf ではないという意味で、コミュニティ構築の取り組みでもあります。その目的は、言語に特化しないアイデアを提案し、コミュニティのメンバー全員が常に心に留めておいてほしいというものです。

RD:コミュニティは言語だけにとどまらず、もっと大きなものにしたいですよね。なぜなら、常にその言語だけを使っているわけではないからです。

LC:まさにその通りです。そして、他のコミュニティに対してもオープンであることも重要です。ソフトウェアを作る意味は何でしょうか? ソフトウェアを作る意味は、すべてのソフトウェアは結局のところ、他の人間の役に立つということです。そして、それが最終的にソフトウェアの良し悪しを決めるのです。それが究極の目標ですよね?

最後に、Zig Showtime は数年間休止していました。パンデミック中に始まり、その後、皆と同じように私もオンライン イベントにひどく疲れてしまい、対面イベントやミートアップなどに切り替えたのです。

そしてもう疲れもなくなったので、ショータイムを再開します。