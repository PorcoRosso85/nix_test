Zigは様々な機能を削っており、かつ全てが明示的になっています:

関数のオーバーロード: できません。
デフォルト引数: ありません。
暗黙的な型変換: 一切出来ません。i8からi16もできません(comptimeならできるけどね)。1とtrueもできません。勝手にクラスのコンストラクタが呼ばれることもありません。
例外: ありません。エラーになったらearly returnするsyntax sugarはありますが、スタックをcatchされるまで遡るような鮭みたいな事もしません。
継承: ありません。unionを使って似たようなことはできますが、もっといい方法があるでしょう。
オペレータのオーバーライド: あるわけないよね。
コンストラクタ・デストラクタ: ありません。勝手に関数呼ばれたら怖いよね。Golangみたいにdeferでスコープを抜ける際の処理を記述することは出来ます。
暗黙的なメモリ確保: ありません。ヒープへのメモリ確保は全て明示的に行う必要があります。ヒープを使うstdlibの関数にはAllocatorを関数に渡す必要があります。
マクロ: ありません。型がないの、怖いと思わない？括弧をつけ忘れただけで意味わからないエラーとか出たこと無い？その代わりといっちゃなんですが、comptimeという機能があって、だいたいそれで実現できます。

上の例の場合には、struct Deviceの唯一のopen()関数が呼ばれ、その引数の型(すなわちdescのまさにその型)も一意に定まり、そこには何の変換もありません。
deviceがアロケータを持っていないならばopen()でヒープが確保されることもありません。
desc + 2は読んで字のごとく数の足し算に他ならず、descは数(整数/浮動小数点数)の型であることも自明です。
スコープを抜けても勝手にデストラクタが呼ばれることもありません。

今回はその中でも重要であり、かつ勉強したての頃にはいまいち扱いづらいcomptimeについて紹介していきます。

## comptime概略

Zigは、「コンパイル時に決まる値か否か」をめっちゃ気にします。神経質です。
コンパイル時に決まる式のことを、comptimeな値と呼びます。
値がcomptimeかどうかは、ある程度コンパイラがルールに基づいて決定します。
また、開発者が明示的に型にcomptime修飾をすることで、その値がcomptimeであることを強制することも出来ます。

### Case 1: MMIO

ニートなので暇な時間にMikanOSをZigに移植して遊んでいるんですが、その中でxHCI(USB)ドライバを書く必要がありました。
xHCは様々なレジスタを持っています:

packed structはメンバ間のパディングをなくしてくれる構造体です。
また、Zigでは整数型として任意のビット幅をとることができるため、u8でもu16でもu99でも使うことが出来ます。
それは良いことですが、こういったMMIOレジスタはアクセスする際のビット幅が仕様で決まっていることが多々あります。
あるレジスタはWORD(16bit)でアクセスし、あるレジスタはDWORD(32bit)でアクセスする、といった具合です。
そんな時、cap_lengthフィールドだけを変更したいとなった時にめんどうです。
このレジスタがDWORDアクセスを強制する場合、cap_lengthだけアクセスするとアクセス違反になってしまいます。

そんな時にcomptimeが役に立ちます。
まずはアクセスできるビット幅を表すAccessWidth enumを定義します:

非常にシンプル。
enum(u8)は、このenumのインスタンスが8bitで表現されることを明示します。
そのメンバーはビット幅を表す4つがあります。
utype()はアクセス幅に対応する整数型を返すユーティリティ関数です。
Zigでは、comptimeである限りtypeを関数の返り値とすることができます。
size()もユーティリティで、enumインスタンスが表現するビット幅を返してくれます。

それを踏まえてMMIOレジスタを表現する構造体を定義します:

この関数は、comptimeな型TとAccessWidthを受け取り、その型を持つレジスタ構造体を返します。
ここでもやはり、関数が型を返しています。
しかも、返される型は_data: Tといった引数で取った型を持っています。
_dataメンバは、実際のレジスタの中身を表す型です。
先程の例で言うと、こんな感じで使います:

これでcapability_regs変数はCapabilityRegisters構造体を指すポインタでありながら、DWORDアクセスをすることができる型を持つことになります。

さてさて、Register()の定義に戻ります。
asize/atypeメンバは、アクセス幅に対応した型とそのサイズを表しています。
返される構造体型のstaticな変数のような扱いになります。
read()はコアの部分で、アクセス幅に対応した幅でアクセスしつつ、もとの構造体の型でデータを返します。
やっていることとしては:

MMIOレジスタをvalというアクセス幅に対応する型(atype)の配列とみなす。
実際のレジスタ型(T)を持つ空の変数retを用意する。
必要な回数(len)だけデータをコピーする
と言った感じです。まぁ実際にどんなことをしているかよりも、型を引数に取ることでその型に応じたメソッドを持つ構造体を作れるということがポイントです。

### Case 2: Partial Type

TypeScriptのようなスクリプト言語には、ある型の一部だけを持つ型を表現する機能があります。
コンパイル型言語ではなかなか無い機能ですが、Zigではcomptimeを使うことで実現できます。

先程の例ではMMIOレジスタからの読み取りをしていましたが、ここでは逆に一部のフィールドのみ書き込みたいとしましょう。
この時、以下のように書くことが出来ます:

まず、read()によって現在の値を取得します。
その後、info変数にvalue引数の型情報を取得します。
valueはanytype型を持ち、comptimeな任意の型を受け取ることができます(よってcomptimeとわざわざ書く必要はありません)。
この時、info.Struct.fieldsはvalue構造体が持つ全てのフィールドを表す配列です。
この配列をforループで回すことで、new変数の対応するフィールドにvalueのフィールドをコピーしていきます。
ここで登場するinline forはcomptimeな場合にのみ使うことができ、コンパイル時にアンローリングされます。
他にはinline switchとかinline whileとかがあります。

これで一部のフィールドだけを変更したいときには以下のように書けます:

### Case 3: 関数も返しちゃえ

少し趣を変えて、今度は割り込み処理を書きたいとしましょう。
x64において、CPUは割り込みを受けるとIDTを探して割り込みベクターに対応するハンドラを呼びます。
このハンドラではレジスタの退避などを行うため、基本的には全割り込みで共通したものを使いたいです。
しかしながら、ここで問題が。
共通したハンドラを使うと、割り込みベクタ(割り込み番号)が何番かが分からなくなってしまいます。
これでは、共通したハンドラからベクタに対応するハンドラを呼び出すことが出来ません。

そこで、Linuxなどではアセンブラで以下のように書いています:

割り込みベクタiを最初にpushqしたあと、jmp early_idt_handler_commonで共通ハンドラに飛ばしています。
この処理をマクロを使って必要な分だけ生成しているというわけです。

この処理、Zigで書くことも出来ます(一部省略):

Zigではcallconvでcalling conventionを指定することが出来ます:

.Naked: 関数のプロローグ/エピローグを生成しない。アセンブラから呼び出す時。
.Win: Windowsの規則に従う。UEFIから呼び出すときとか。
.C: Cの規則に従う。Cから呼び出す時とか。
generateIsr()は、ベクタ番号を受取り、そのベクタをpushqした後に共通処理を呼び出すような関数を返します。
アセンブラの.ifとかを使わず、卍高級言語卍の構文を使って返す関数の中身を制御することが出来ます。
Zigは、こんな感じのメタプロができる言語です。そう、comptimeならね。

返した関数は実際に関数として実体を持ち、以下のように生成することが出来ます:

でました、inline for。
これによって、コンパイル時に0~num_system_exceptions - 1までの分だけ割り込みハンドラ用の関数が実際に生成されます。
nmで見てみると、こんな感じです:

もう意味わからないアセンブラのマクロなんて使わなくて良い
